---
title: "Note on OBI score aggregation"
author: "W.H. Riechelman (NMI)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: [packages.bib, vignettes_references.bib]
vignette: >
  %\VignetteIndexEntry{the-open-soil-index}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

# Introduction
The OBIC is a framework that takes a multitude of soil parameters and variables from agricultural fields and ultimately gives a single value expressing the soil quality of that field. To take this multitude of measured, modelled and calulated values to a single value between 0 and 1, three aggregation steps take place as illustrated below.

```{r include score integration image, echo=FALSE, out.width = '85%', out.height = '85%', fig.cap = 'Figure 1. Graphic representation of how measured soil properties are aggregated to scores.'}
# include graphic
knitr::include_graphics('OBIC_score_integratie.png')
```

There is no scientific principle dictating how this aggregation should be done and there are several ways to do the aggregation. For example; averaging, linearly weighted averaging, logistically weighted averaging.
This document dives deeper into the three aggregation steps within the framework and will explain the why a certain method of aggregation was used. We will also explore alternative methods of aggregation and compare these with the chosen method to illustrate the influence the aggregation method has on the final score and act as a kind of sensitivity analysis.
Demonstration of aggregation will be performed using  the dataset `binnenveld`. The dataset contains soil properties from 11 agricultural fields in the surroundings of Wageningen, with different soil texture and land use, and is documented in `?binnenveld`.

```{r load binnenveld}
# load packages
library(OBIC); library(data.table); library(ggplot2)
# load data
dt <- OBIC::binnenveld[ID==1]
```

# Aggregation
Between calculating soil function scores and aggregating a reformatting step takes place. 
The following things are done during reformatting:

  * it is assessed which indicators are relevant for a field given its soiltype and crop category using the `weight.obic` table.
  * year numbers are assigned from 1 to n with one being the most recent year (used for aggregating over years)
  * a molten data.table is created with all indicators in a single column and soiltype, crop category and year as identifying variables
  * categories are assigned to indicators (chemical, physical, biological, environmental, management)
  * a data.table with the number of indicators per category is made (used in the aggregation of indicators)
  * a correction factor per score is calculated based on the height of the score (used later to give more weight to low scores)
  * soil function scores irrelevant to the land use are set to -999
  
At the beginning of the next step, an indicator data.table is created based on the molten data.table created in the reformatting step. This data.table uses the soil function scores ajusted for their applicability for the soiltype and crop category. 

```{r reformatting code, echo = TRUE, eval=FALSE}
  # Step 3 Reformat dt given weighing per indicator and prepare for aggregation  ------------------
    
    # load weights.obic (set indicator to zero when not applicable)
    w <- as.data.table(OBIC::weight.obic)
    
    # Add years per field
    dt[,year := .I, by = ID]
    
    # Select all indicators used for scoring
    cols <- colnames(dt)[grepl('I_C|I_B|I_P|I_E|I_M|year|crop_cat|SOILT',colnames(dt))]

    # Melt dt and assign main categories for OBI
    dt.melt <- melt(dt[,mget(cols)],
                    id.vars = c('B_SOILTYPE_AGR','crop_category','year'), 
                    variable.name = 'indicator')
    
    # add categories relevant for aggregating
    # C = chemical, P = physics, B = biological, BCS = visual soil assessment
    # indicators not used for integrating: IBCS and IM
    dt.melt[,cat := tstrsplit(indicator,'_',keep = 2)]
    dt.melt[grepl('_BCS$',indicator) & indicator != 'I_BCS', cat := 'IBCS']
    dt.melt[grepl('^I_M_',indicator), cat := 'IM']
    
    # Determine number of indicators per category
    dt.melt.ncat <- dt.melt[year==1 & !cat %in% c('IBCS','IM')][,list(ncat = .N),by='cat']
    
    # add weighing factor to indicator values
    dt.melt <- merge(dt.melt,w[,list(crop_category,indicator,weight_nonpeat,weight_peat)], 
                     by = c('crop_category','indicator'), all.x = TRUE)
    
    # calculate correction factor for indicator values (low values have more impact than high values, a factor 5)
    dt.melt[,cf := cf_ind_importance(value)]
    
    # calculate weighted value for crop category
    dt.melt[,value.w := value]
    dt.melt[grepl('veen',B_SOILTYPE_AGR) & weight_peat < 0,value.w := -999]
    dt.melt[!grepl('veen',B_SOILTYPE_AGR) & weight_nonpeat < 0,value.w := -999]
    
```

## Weighing values
To aggregate scores, the relevant columns and rows are taken from the molten data.table.

```{r echo = TRUE, eval=FALSE}
 # Step 5 Add scores ------------------
    
    # subset dt.melt for relevant columns only
    out.score <-  dt.melt[,list(cat, year, cf, value = value.w)]
  
    # remove indicator categories that are not used for scoring
    out.score <- out.score[!cat %in% c('IBCS','IM','BCS')]
```    

The values are weighted using the correction factor calculated previously using `cf_ind_importance()`, giving more weight to lower scores. This way the lowest value, supposedly also to most limiting factor for crop production, becomes more important. Consequently, improving a low score by 0.1 is easier than improving a high score by this same amount, making it more worthwhile to invest in the poorest and most limiting theme.

```{r echo = TRUE, eval=FALSE}    
    # calculate weighted average per indicator category
    out.score <- out.score[,list(value = sum(cf * pmax(0,value) / sum(cf[value >= 0]))), by = list(cat,year)]
  
      # for case that a cat has one indicator or one year and has NA
      out.score[is.na(value), value := -999]
```

## Aggregating over years
Multiple years are used (usually 10) to capture the entire crop rotation (crop rotation in the Netherlands are hardly ever longer than 10 years). When aggregating over years, another correction factor is used to give more weight to recent years. Calculation of the correction factor is done with a logistic function.

These would be the correction factors for a period of eleven years:
```{r output year cf}
  # create data
  y <- 1:11
  cf <- log(12 - pmin(10, y))
  cat(cf)
```

The most recent year carries about `r round(cf[1]/cf[10],digits =1)` the weight of the tenth year. Notice that years ten and eleven have the same correction factor value, the minimum cf value for a year is equal to that of year ten.

More priority (weight) is given to recent years because these are more reflective of the current situation. Additionally, changes in management or soil properties take more immediate effect in subsequent years.

Aggregation of scores over years is done with the following two lines of code. Per indicator an average value is calculated with weights from the correction factor described above.  Side note: The function `obic_field()` has similar lines of code for calculating individual indicators which are given as optional outputs when output is set to 'all' or 'indicators'. Aggregating indicators over years is done in the same fashion.
      
```{r echo = TRUE, eval=FALSE}
            
      # calculate correction factor per year; recent years are more important
      out.score[,cf := log(12 - pmin(10,year))]
  
    # calculate weighted average per indicator category per year
    out.score <- out.score[,list(value = sum(cf * pmax(0,value)/ sum(cf[value >= 0]))), by = cat]
```

This gives us a single score for each of the five indicators (chemical, physical, biological, management, and environmental).

## Aggregating to single OBI score
To aggregate the five indicators to a single, holistic, OBI-score, they are weighed logistically using the number of soil functions underlying the indicator. The number of soil functions per indicator was retrieved previously with the line `dt.melt.ncat <- dt.melt[year==1 & !cat %in% c('IBCS','IM')][,list(ncat = .N),by='cat']`. Now its merged with our score data.table.

```{r echo = TRUE, eval=FALSE}
      # merge out with number per category
      out.score <- merge(out.score,dt.melt.ncat, by='cat')
```

The correction factor for weighing indicators based on the number of soil functions they are made up of is done like this:

```{r echo = TRUE, eval=FALSE}
      # calculate weighing factor depending on number of indicators
      out.score[,cf := log(ncat + 1)]
```

The weights for indicators with 1 to 10 soil functions are: `r round(log(1:10 +1),2)`. Thus, an indicator based on 10 soil functions affects the total score roughly `r round(log(1:10 +1)[10]/log(1:10 +1)[1],1)` times more than an indicator based on 1 soil function. The idea behind giving more weight to indicators with more underlying soil functions sprouts from the idea that such an indicator is better supported by measurable data or more important. 
Furthermore, by aggregating soil functions to indicators and then to a score rather than directly from soil functions to a score; soil functions from indicators with few underlying soil functions, affect the holistic score more than soil functions in indicators with many soil functions. For example, if there is one biological soil function, its weight in affecting the holistic score is `r round(log(1+1),2)`, while a soil function within a chemical indicator with nine soil functions individually only weighs `r round(log(9+1)/9,2)` (`cf := log(9+1)`). While this example on indicator level, biology only weighs `r round(log(1+1),2)` and chemical `r round(log(9+1),2)`.

After the aggregation there is just a bit of code to format the names of the scores.

```{r echo = TRUE, eval=FALSE}
    # calculated final obi score
    out.score <- rbind(out.score[,list(cat,value)],
                       out.score[,list(cat = "T",value = sum(value * cf / sum(cf)))])
  
    # update element names
    out.score[,cat := paste0('S_',cat,'_OBI_A')]
    out.score[, value := round(value,3)]
```

## Brief recap

* Soil functions with low values gain more weight than ones with heigh values because these soil functions are supposed to be more limiting and this makes it more worthwhile (both in reality as for the OBI score) to invest in improving low scores
* Values from recent years count more than values from long ago. Recent years are more reflective of the current situation and it becomes easier to see the effect of changes in management or soil properties in subsequent years
* Indicators with more underlying soil functions have more weight in determining the total OBI score. This is because these indicators are better understood and supported and may be more important. However, individual soil functions of indicators with few soil functions have more influence on the total OBI score compared to individual soil functions of indicators with many soil functions.

## Comparison with other aggregation methods
```{r make mock data, eval= TRUE}
# make mock data and calculate scores with different aggregation methods (averaging without weight and averaging with linearly changing weight)
# data like:
# soil_function_value|indicator|group|year|cf_base|cf_noweight|cf_linearweight|score_base|score_noweight|score_linearweight

# visualise differences

# make veldnr
fieldid <- 1

# make indicator
inds <- c('I_C_CEC', 'I_C_CU', 'I_C_K', 'I_C_MG', 'I_C_N', 'I_C_P', 'I_C_PH', 'I_C_S', 'I_C_ZN',
          'I_B_DI', 'I_B_SF', 
          'I_E_NGW', 'I_E_NSW',
          'I_P_CEC', 'I_P_CO', 'I_P_CR', 'I_P_DS', 'I_P_DU', 'I_P_SE', 'I_P_WRI', 'I_P_WS')
# inds <- sort(rep(inds, 10))

# make jaar
year <- 1:10

# combine in dt
dt <- data.table(field = sort(rep(fieldid,length(inds)*length(year))),
                 indicator = sort(rep(inds, length(year)*length(fieldid))),
                 year = rep(year, length(inds)*length(fieldid))
                 )

# add category
dt <- dt[,cat := tstrsplit(indicator,'_',keep = 2)]

# iteratively add fields
dto <- data.table(field = NULL, indicator = NULL, year = NULL)
for(i in 1:100){
  dtn <- dt
  dtn <- dtn[,field := i]
  dto <- rbindlist(list(dto, dtn))
}

# dto is a almost ready set of 100 fields, only values and value description need to be added

# make baseline
dt1 <- copy(dto)
dt1 <- dt1[,treatment := 'baseline']
dt1 <- dt1[,value := rnorm(n = nrow(dt1),mean = 0.7, sd = 0.1)]

# make treatment where c = 0.3
dt2 <- copy(dto)
dt2 <- dt2[,treatment := 'low C scores']
dt2 <- dt2[cat == 'C',value := rnorm(n = nrow(dt2[cat=='C']),mean = 0.3, sd = 0.1)]
dt2 <- dt2[!cat == 'C',value := rnorm(n = nrow(dt2[!cat=='C']),mean = 0.7, sd = 0.1)]

# make treatment where B = 0.3
dt3 <- copy(dto)
dt3 <- dt3[,treatment := 'low B scores']
dt3 <- dt3[cat == 'B',value := rnorm(n = nrow(dt3[cat=='B']),mean = 0.3, sd = 0.1)]
dt3 <- dt3[!cat == 'B',value := rnorm(n = nrow(dt3[!cat=='B']),mean = 0.7, sd = 0.1)]

# make treatment where one C indicator = 0
dt4 <- copy(dto)
dt4 <- dt4[,treatment := 'one low C']
dt4 <- dt4[indicator == 'I_C_CEC',value := 0]
dt4 <- dt4[!indicator == 'I_C_CEC',value := rnorm(n = nrow(dt4[!indicator == 'I_C_CEC']),mean = 0.7, sd = 0.1)]

# make where one B indicator = 0
dt5 <- copy(dto)
dt5 <- dt5[,treatment := 'one low B']
dt5 <- dt5[indicator == 'I_B_DI',value := 0]
dt5 <- dt5[!indicator == 'I_B_DI',value := rnorm(n = nrow(dt5[!indicator == 'I_B_DI']),mean = 0.7, sd = 0.1)]

# make treatment where recent years score low and old years high
dt6 <- copy(dto)
dt6 <- dt6[,treatment := 'Recent years low']
dt6 <- dt6[year %in% 1:5, value := rnorm(n = nrow(dt6[year %in% 1:5]), mean = 0.3, sd = 0.1)]
dt6 <- dt6[!year %in% 1:5, value := rnorm(n = nrow(dt6[!year %in% 1:5]), mean = 0.7, sd = 0.1)]

# make treatment where recent years score high and old years low
dt7 <- copy(dto)
dt7 <- dt7[,treatment := 'Recent years high']
dt7 <- dt7[!year %in% 1:5, value := rnorm(n = nrow(dt7[!year %in% 1:5]), mean = 0.3, sd = 0.1)]
dt7 <- dt7[year %in% 1:5, value := rnorm(n = nrow(dt7[year %in% 1:5]), mean = 0.7, sd = 0.1)]

# combine all data
dta <- rbindlist(list(dt1, dt2, dt3, dt4, dt5, dt6, dt7))

# make sure all values are between 0 and 1
dta <- dta[value<0, value := 0]
dta <- dta[value>1, value := 1]

```








```{r, eval=FALSE}
  obic_field(B_SOILTYPE_AGR =  dt$B_SOILTYPE_AGR, B_GWL_CLASS =  dt$B_GWL_CLASS,
             B_SC_WENR = dt$B_SC_WENR, B_HELP_WENR = dt$B_HELP_WENR, B_AER_CBS = dt$B_AER_CBS,
             B_LU_BRP = dt$B_LU_BRP, A_SOM_LOI = dt$A_SOM_LOI, A_SAND_MI = dt$A_SAND_MI,
             A_SILT_MI = dt$A_SILT_MI, A_CLAY_MI = dt$A_CLAY_MI, A_PH_CC = dt$A_PH_CC,
             A_CACO3_IF = dt$A_CACO3_IF, A_N_RT = dt$A_N_RT, A_CN_FR = dt$A_CN_FR,
             A_COM_FR = dt$A_COM_FR, A_S_RT = dt$A_S_RT, A_N_PMN = dt$A_N_PMN,
             A_P_AL = dt$A_P_AL, A_P_CC = dt$A_P_CC, A_P_WA = dt$A_P_WA, A_CEC_CO = dt$A_CEC_CO,
             A_CA_CO_PO = dt$A_CA_CO_PO, A_MG_CO_PO = dt$A_MG_CO_PO, A_K_CO_PO = dt$A_K_CO_PO,
             A_K_CC = dt$A_K_CC, A_MG_CC = dt$A_MG_CC, A_MN_CC = dt$A_MN_CC,
             A_ZN_CC = dt$A_ZN_CC, A_CU_CC = dt$A_CU_CC, output = 'obic_score')
```

